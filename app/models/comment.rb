# encoding: utf-8

class Comment < ActiveRecord::Base
  belongs_to :user
  belongs_to :target, :polymorphic => true
  belongs_to :project
  has_many   :events, :as => :target, :dependent => :destroy
  after_create :notify_target_if_supported
  after_create :update_state_in_target
  serialize :state_change, Array

  is_indexed :fields => ["body"], :include => [{
      :association_name => "user",
      :field => "login",
      :as => "commented_by"
    }]

  attr_protected :user_id

  validates_presence_of :user_id, :target, :project_id
  validates_presence_of :body, :if =>  Proc.new {|mr| mr.body_required?}

  scope :with_shas, proc{|*shas|
    {:conditions => { :sha1 => shas.flatten }, :include => :user}
  }



  def state=(new_state)
    return if new_state.blank?
    result = []
    result << new_state
    self.state_change = result
  end

  def state_changed_to
    state_change.to_a.last
  end

  def state_changed_from
    state_change.to_a.size > 1 ? state_change.first : nil
  end

  def body_required?
      return true
  end

  # +lines_str+ is a representation of the first and last line-number
  # tuple (as generated by Diff::Unified::Generator) and the lines the
  # comment span, in the follow format:
  # first_tuple:last_tuple+line_span
  def lines=(lines_str)
    start, rest = lines_str.split(":")
    raise "invalid lines format" if rest.blank?
    last, amount = rest.split("+")
    if start.blank? || last.blank? || amount.blank?
      raise "invalid lines format"
    end
    self.first_line_number = start
    self.last_line_number = last
    self.number_of_lines = amount
  end

  def lines
    "#{self.first_line_number}:#{self.last_line_number}+#{self.number_of_lines}"
  end

  def sha_range
    first, last = sha1.split("-")
    first..(last||first)
  end

  def applies_to_line_numbers?
    return !first_line_number.blank?
  end


  def editable_by?(a_user)
    creator?(a_user) && recently_created?
  end

  def creator?(a_user)
    a_user == user
  end

  def recently_created?
    created_at > 10.minutes.ago
  end

  protected
    def notify_target_if_supported
      if target && NOTIFICATION_TARGETS.include?(target.class)
          target_user = target.user
        return if target_user == user
        deliver_notification_to(target_user)
      end
    end


end
